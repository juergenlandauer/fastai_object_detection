# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/00_core.ipynb (unless otherwise specified).

__all__ = ['show_binmask', 'TensorBinMasks', 'BinaryMasksBlock', 'TensorBinMasks2TensorMask', 'ObjDetLearner',
           'InstSegLearner']

# Cell

from fastai.vision.all import *

# Cell

@delegates(plt.Axes.imshow, keep=True, but=['shape', 'imlim'])
def show_binmask(im, ax=None, figsize=None, title=None, ctx=None, **kwargs):
    "Function to show binary masks with matplotlib"
    if hasattrs(im, ('data','cpu','permute')):
        im = im.data.cpu()
    if not isinstance(im,np.ndarray): im=array(im)
    ax = ifnone(ax,ctx)
    if figsize is None: figsize = (_fig_bounds(im.shape[0]), _fig_bounds(im.shape[1]))
    if ax is None: _,ax = plt.subplots(figsize=figsize)
    for m in im:
        c = (np.random.random(3) * 0.6 + 0.4)
        #draw_mask(ax, m, c)
        color_mask = np.ones((*m.shape, 3)) * c
        ax.imshow(np.dstack((color_mask, m * 0.5)))
        ax.contour(m, colors=[color_mask[0, 0, :]], alpha=0.4)
    if title is not None: ax.set_title(title)
    ax.axis('off')
    return ax

def _fig_bounds(x):
    r = x//32
    return min(5, max(1,r))

# Cell

class TensorBinMasks(TensorImageBase):
    "Tensor class for binary mask representation"
    def show(self, ctx=None, **kwargs):
        return show_binmask(self,ctx=ctx, **{**self._show_args, **kwargs})

# Cell

def BinaryMasksBlock():
    "A `TransformBlock` for binary masks"
    return TransformBlock(type_tfms=lambda x: tuple(apply(PILMask.create,x)), batch_tfms=IntToFloatTensor)

# Cell

def _bin_mask_stack_and_padding(t, pad_idx=0):
    "Function for padding to create batches when number of objects is different"
    stacked_masks = [torch.stack(t[i][1], dim=0) for i in range(len(t))]
    imgs = [t[i][0] for i in range(len(t))]
    bboxes = [t[i][2] for i in range(len(t))]
    labels = [t[i][3] for i in range(len(t))]
    samples = L(t for t in zip(imgs,stacked_masks,bboxes,labels))
    samples = [(s[0], *_clip_remove_empty_with_mask(*s[1:])) for s in samples]
    max_len = max([len(s[3]) for s in samples])
    def _f(img,bin_mask,bbox,lbl):
        bin_mask = torch.cat([bin_mask,bin_mask.new_zeros(max_len-bin_mask.shape[0], bin_mask.shape[-2], bin_mask.shape[-1])])
        bbox = torch.cat([bbox,bbox.new_zeros(max_len-bbox.shape[0], 4)])
        lbl  = torch.cat([lbl,lbl.new_zeros(max_len-lbl.shape[0])+pad_idx])
        return img,TensorBinMasks(bin_mask),bbox,lbl
    return [_f(*s) for s in samples]

def _clip_remove_empty_with_mask(bin_mask, bbox, label):
    bbox = torch.clamp(bbox, -1, 1)
    empty = ((bbox[...,2] - bbox[...,0])*(bbox[...,3] - bbox[...,1]) <= 0.)
    return (bin_mask[~empty], bbox[~empty], label[~empty])

# Cell

class TensorBinMasks2TensorMask(Transform):
    "Class to transform binary masks to fastai's `TensorMask` class to make fastai's transforms available"
    def encodes(self, x:TensorBinMasks):
        return TensorMask(x)
    def decodes(self, x:TensorMask):
        return TensorBinMasks(x)

# Cell

class ObjDetLearner(Learner): pass

# Cell

class InstSegLearner(Learner): pass